---
title: "FA Talk"
author:  |
  <div class="title"><span style="font-size:125%; font-variant:small-caps; font-style:normal; ">Michael Clark</span><br>
  <!-- <img src="img/signature-acronym.png" style="width:33%; padding:10px 0;"> <br> -->
  <!-- <img src="img/ARC-acronym-signature.png" style="width:22%; padding:10px 0;"> </div> -->
date: "`r Sys.Date()`"
output: 
  html_document: 
    highlight: pygments
    theme: sandstone
css: standard_html.css
---

```{r setup, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment=NA, message = FALSE, warning=FALSE, R.options=list(width=120), 
                      cache.rebuild=F, cache=TRUE,
                      fig.align='center', dev = 'svg', dev.args=list(bg = 'transparent'))
knitr::opts_knit$set(root.dir = '../')
library(tidyverse); library(htmltools); library(lazerhawk); library(heatR); library(pander); library(lavaan)
```


## Thinking about FA

- Dimension Reduction
- Matrix Factorization
- Latent Linear Models
- Measurement error


## PCA

Seek to find orthogonal factors to minimize reconstruction error.

$$\mathscr{Loss} = X - ZW^T$$

X is the $NxD$ matrix of $N$ observations of $D$ variables, $Z$ are the $N x L$ component scores where L < D, while $W$ are the $DxL$ weights, typically referred to as the <span class="emph">factor loading</span> matrix.

Each component, or factor, created accounts for less of the variance in the original data.  With all components, 

$$X = ZW^T$$

The MNIST data contains 28 by 28 pixel images of digits 0-9.  If we unroll the data to 784 columns, each row represents a single digit.  We can see in the following how well we can reconstruct a digit via PCA.  Even with only two components we can get a sense of what we're looking at.  With all components the reconstruction is perfect.

<img src="../img/pca_recon.png" style="display:block; margin: 0 auto;">
<!-- I guess html ignores working directory -->

### Example

Let's see an example with more digestible results.  The following data are 16 multiple choice ability items taken from the Synthetic Aperture Personality Assessment (SAPA) web based personality assessment project. There are 1525 total subjects, and four categories of questions.

- reason: verbal reasoning questions
- letter: In the following alphanumeric series, what letter comes next?
- matrix: A matrix reasoning task
- rotate: spatial rotation task

```{r data_cogab, echo=1:2}
library(psych)
cog_ability = psych::iqitems
DT::datatable(cog_ability[1:10,],
              rownames = F,
              options = list(dom='t', 
                             scrollX=T,
                             autoWidth=T,
                             columnDefs=list(list(width = '100px', targets='_all'),
                                             list(className = 'dt-center', targets = '_all'))),
              width='100%')
```

<br>


Let's do a PCA.  We'll look at four components, though remember that PCA technically returns as many components as there are variables. You're just seeing part of the results. Note that PCA almost universally requires you to <span class="emph">standardize</span> the data,  so that each variable has the same variance.  Otherwise you'll just get components reflecting the relative variances. In what follows the PCA is done on the correlation matrix, which amounts to the same thing.

```{r pc_cog, echo=-3}
pc = principal(cog_ability, 4)
pc
p = ncol(cog_ability)
```

First focus on the portion of the output where it says `SS loadings` . The first line is the sum of the squared loadings[^eigen] for each  component (in this case where we are using a correlation matrix as the basis, summing across all `r p` possible components would equal the value of `r p`). The `Proportion Var` tells us how much of the overall variance the component accounts for out of all the variables (e.g. `r paste(round(print(pc)$Vaccounted[1], 2), '/', p, ' = ', round(print(pc)$Vaccounted[1]/p, 2))`).  The `Cumulative Var` tells us that `r pc$factors` components make up over `r round(sum(colSums(pc$loadings^2))/p, 2)*100`% the variance. The others are the same thing just based on the `r pc$factors` retained components rather than all `r p` variables (i.e. the cumulative explained variance would = 1). We can see that the second component accounts for less variance, and this would continue with additional components, where each accounts for a decreasing amount of variance.

Some explanation of the other parts of the output:

- `h2`: the amount of variance in the item/variable explained by the (retained) components. It is the sum of the squared loadings, a.k.a. <span class="emph">communality</span>. For example, the first reasoning item shares only 38% of its variance with these components.
- `u2`: 1 - h2
- `com`: A measure of complexity. A value of 1 might be seen for something that loaded on only one component, and zero otherwise (a.k.a. perfect simple structure).


<span class='emph'>Loadings</span>, also referred to as the <span class="emph">pattern matrix</span>, in this scenario represent the estimated correlation of an item with its component, and provide the key way in which we interpret the factors. As an example, we can reproduce the loadings by correlating the observed variables with the estimated component scores[^rotated].

```{r pc_LoadingsReproduced, dependson=-1}
cor(cog_ability, pc$scores, use = 'pair') %>% round(2)
```


It can be difficult to sort it out just by looking at the values, so we'll look at it visually. In the following plot, stronger loadings are indicated by blue, and we can see the different variables associated with different components. 

```{r pc_LoadingsVis, echo=F, cache=FALSE}
library(htmltools)
# tags$div(style="width:50%; margin-left:auto;  margin-right:auto",
#          d3heatmap::d3heatmap(pc$loadings, dendrogram='none',
#                               colors=scales::col_bin(RColorBrewer::brewer.pal(11, "RdBu"), 
#                                                      domain=c(-.3,1), bins=50), 
#                               width=500)
#          )
tags$div(style="width:50%; margin-left:auto;  margin-right:auto",
heatmaply::heatmaply(pc$loadings, dendrogram='none',
                     colors=scales::col_bin(RColorBrewer::brewer.pal(11, "RdBu"), domain=c(-1,1), bins=50)(sort(pc$loadings)),
                     hide_colorbar=T, 
                     plot_method='ggplot'
                     ) %>% 
  plotly::layout(yaxis = list(showline = F),
         xaxis = list(showline = F)
         )
, width=500
)
```

<br>

```{r biplot, echo=FALSE}
# spider(1:8, data=cor(cog_ability[,1:8], use='pair'), cex.lab=.5, scale=1)
biplot.psych(pc, col = viridis::viridis(3, alpha = .5), hist.col = '#00aaff80')

# fa.graph(pc, out.file = 'FA_workshop/pc_cog_graph.gv',
#          node.font = 'Roboto',
#          edge.font = 'Roboto',
#          rank.direction = 'TB',
#          main='PCA Results',
#          fontize=10,
#          bgcolor=transparent,
#          arrowhead=none)
tags$div(style="width:50%; margin-left:auto;  margin-right:auto; font-size:50%",
         DiagrammeR::grViz('FA_workshop/pc_cog_graph.gv', width='100%', height='400px')
)
```



Interpretation is the fun, but commonly difficult, part. In this case, the variables don't appear to be grouping like we'd expect, except for some of the reasoning scores[^badfactor].  It's worth mentioning the <span class="emph">naming fallacy</span> at this point.  Just because we associate a factor with some concept, doesn't make it so. In addition, for PCA the goal is not interpretation, but to reduce the data while retaining as much of the variance as possible.


### PCA Summary

Why do it? 

- Reduce the dimensions of the data
- Retain as much variance as possible

Issues

- It might not be the best choice with some data types
- It is not the choice to make if you are wanting to understand the *co*variance in the data (though it will often agree with methods that do)
- Non-numeric or mixed data types


Other stuff

- Scale the variables
- Biplots are ugly



## FA

Now let's examine what is sometimes called *common* factor analysis, and also sometimes *exploratory* factor analysis in the social sciences, and even 'classical' or 'traditional', but typically just <span class="emph">factor analysis</span> (FA) everywhere else.  While we can use both PCA and FA for similar reasons (dimension reduction) and even have similar interpretations (in terms of loadings), there are some underlying subtleties between the two that provide unique distinctions.  Noting these distinctions with some detail will require some matrix notation, but for readers not so keen on such presentation they may note the images and concluding points.

$$X \approx ZW^T$$

First let's revisit PCA, where we can depict it conceptually as an approach where we attempt to approximate the correlation matrix in terms of the product of components, represented by our loading matrix $L$.

$$R = LL'$$
and

$$C = XW$$

In other words, each component *score* $C$, i.e. the score for a particular observation with regard to the component, is a weighted combination of the $p$ observed variables $X$, the weights (with weight/loading matrix $W$) of which are determined by the loadings, but yet do not say anything about the correlations between the variables.

Things are different with factor analysis. Now the causal flow is in the other direction, originating with the latent variables. 

$$X \approx FW$$

Each observed variable $x$ is a function of the latent variables that it is associated with.  In addition, we also take into account the uniquenesses $\Psi$, or that part which the factors do not explain.


And to reproduce the correlation matrix:

$$R \approx LL'$$
$$R = LL' + \Psi$$

So if we just use the loadings from the FA, we cannot reproduce the correlation matrix exactly, we need to add the uniquenesses as well.

What this amounts to conceptually are a few key ideas:

- Factor analysis focuses on covariance. PCA focuses on variance.
- Factors are the cause of the observed variables, variables are the cause of components.
- Factor analysis does not assume perfect measurement of observed variables.


```{r fa_res}
fa_model = fa(cog_ability, 4, rotate='oblimin')
fa_model
```



```{r fa_LoadingsVis, echo=F, cache=FALSE}
tags$div(style="width:50%; margin-left:auto;  margin-right:auto",
heatmaply::heatmaply(fa_model$loadings, dendrogram='none',
                     colors=scales::col_bin(RColorBrewer::brewer.pal(11, "RdBu"), domain=c(-1,1), bins=50)(sort(pc$loadings)),
                     hide_colorbar=T, 
                     plot_method='ggplot'
                     ) %>% 
  plotly::layout(yaxis = list(showline = F),
         xaxis = list(showline = F)
         )
, width=500
)
```




## FA for measurement

### "Confirmatory" Factor Analysis


```{r eval=FALSE}
modelCode = "
  verbal =~ reason.4 + reason.16 + reason.17 + reason.19
  spatial =~ rotate.3 + rotate.4 + rotate.6 + rotate.8

  # not necessary
  # verbal ~~ spatial

  # if you don't want them correlated
  # verbal ~~ 0*spatial
"

famod = cfa(modelCode, data=cog_ability)
summary(famod, standardized=T, rsq=T, nd=2)
pars = parameterEstimates(famod, standardized=T)
```



### SEM
### IRT

## As latent linear models


### FA

$$ X \sim \mathcal{N}(ZW^T + \mu, \Psi) $$
$\mu$ are the intercepts, $\Psi$ is a $DxD$ covariance matrix.


### Probabilistic PCA

For probabilistic PCA $\Psi$ is $\sigma^2I$.

### PCA

For standard PCA, $\sigma \rightarrow 0$,

## Count-based Matrix Factorization

Commonly our data regards counts or otherwise compositional data.  In this case we can use techniques that are better suited to such data.
 
### NMF

Non-negative matrix factorization is similar to PCA, just with the constraint that scores and weights be positive.  It is (in the usual implementation) identical to probabilistic latent semantic analysis.

<img src="../img/nmf_recon10.png" style="display:block; margin: 0 auto;">

### LDA

<span class="emph">Latent Dirichlet Allocation</span> takes a different approach to deal with count data. The classic example regards text analysis, where LDA is applied to word frequencies across topics.  Consider a document-term matrix where each row regards a document, and each column a word or term.  LDA looks for latent *topics* that are probability distributions over the *terms*.    There is a probability distribution for the topics as well as the terms, and given both, we will see some occurrence of the term in each document. Each *document* can be seen a mix of topics.

In the factor analysis sense, each variable (the term) will have some probability of occurring for a given topic, i.e. factor. One can think of the term/variable probabilities for a specific topic similar to how we did loadings in the factor analysis sense.  Every variable will have some non-zero probability of occurrence for a given factor, but often they are essentially zero. Factor scores are the document topic probabilities.


Given the probabilities of topics and terms within topics, there is a multinomial draw of counts for an observation.  With this probabilistic result, there isn't a 'reconstruction' connotation with LDA.  However we can simulate a mulinomial draw based on the total counts we see.  For example, let's assume 5 terms seen a total of 20 times given some probability.

```{r multinom_ex, echo=-1}
set.seed(1234)
t(rmultinom(1, size = 20, prob=5:1)) # first term is most likely, 5th term is least likely
```

Those are the counts we see for a given observation. 


LDA wouldn't be the best tool if your goal is prediction, and you don't care much about interpretation.

LDA is basically NMF with Dirichlet priors on the topics.  


<img src="../img/lda_recon.png" style="display:block; margin: 0 auto;">

## Latent classes

Take a look at the following data. It regards the waiting time between eruptions and the duration of the eruption (both in minutes) for the Old Faithful geyser in Yellowstone National Park, Wyoming, USA.

```{r faithfulPlot, echo=F}
data("faithful")
library(plotly)
plot_ly(data=faithful, x=~eruptions, y=~waiting) %>% 
  lazerhawk::theme_plotly()
```

In some contexts, possibly way too many, some assume the latent variables are discrete in nature rather than continuous.  In this case, the dimension reduction occurs along the *rows* rather than the columns.  We'll talk about two types.

 
### Mixture models

A basic approach for categorical latent variable analysis from a model based perspective[^cluster] could be seen as follows:

1. Posit the number of clusters you believe there to be
2. For each observation, estimate those probability of coming from either cluster assuming some underlying distribution
3. Assign observations to the most likely class (i.e. the one with the highest probability)

Typical methods are assuming an underlying normal distribution, such that each observation is the weighted some of its likelihood under the parameters for each proposed cluster with their respective estimated parameters.  For example with two clusters, each with an estimated mean and variance, we get the likelihood for a particular observation for each cluster.  We weight them by its estimated probability of membership in that cluster.

As an example, we'll use <span class="pack">mclust</span> on the old faithful data, positing 2 clusters.

```{r clus_mclust, echo=1:3}
library(mclust)
mod = Mclust(faithful, G = 2)
summary(mod)

par(mfrow=c(1,2))
plot(mod, what='classification')
plot(mod, what='uncertainty')
graphics::layout(1)
```

We can see that things break out more or less as we might expect, though there is a bit more uncertainty with observations in the middle.


The nice thing about model based approaches is that if we want to compare different solutions we can use the same tools we do in regression settings.  Here, mclust does a search over many models (not just differences in cluster sizes, but also things like equal variances, shape, etc.)  and selects the 'best' model according to BIC.

```{r clus_mclust2, echo=1}
mod = Mclust(faithful, verbose=F)
par(mfrow=c(1,2))
plot(mod, what='BIC')
plot(mod, what='classification')
graphics::layout(1)
```



#### For regression

Mixture models are often used in the regression setting, similar to the latent class setting that we've been describing.  One approach regards the outcome of interest, which you think has latent categories, and you model it as such. In a standard regression setting you would get two sets of output, one for each class, along with estimated probabilities of class membership for each observation.


```{r flexmixEruptions_workshop, echo=-1}
set.seed(1234)
library(flexmix)
mod = flexmix(eruptions~waiting,  data=faithful, k = 2)
summary(mod)
```

We can see from the summary about 2/3 are classified to one group. We also get the estimated means and standard deviations for each group, as well as note respective probabilities of each observation for each class.  Note that the group labels are completely arbitrary.

```{r flexmixEruptions2_workshop, echo=-2}
parameters(mod)    # means (Intercept) and std dev (sigma) for each group
head(mod@posterior$scaled, 10) %>% round(3) %>% data.frame() %>% pander::pander()  # show some estimated probabilities
```

<br>

The key idea is as before, that the response is from two distributions, e.g. two normal distributions, each with their own mean, modeled by covariates, and some variance.  This very commonly applied in cases where there are many zeros in the data, leading to <span class="emph">zero-inflated</span>, <span class="emph">hurdle</span> and similar models, where the zeros are modeled by a logistic regression and the counts by Poisson or negative binomial, but the approach is much more general.


 
### "Cluster analysis"
 
#### K-means

K-means is hands-down the most commonly used clustering method.  Conceptually it's fairly straightforward- find $k$ clusters that minimize the variance of its members from the mean of its members.  As such it's easy to implement in standard data settings.

#### Hierarchical

Hierarchical methods can be thought of as a clustering 
 
### Predictive Modeling

### Issues

#### Model Selection

Non-model based methods provide no non-arbitrary way of selecting the number of clusters within a particular method, or comparing different approaches to the same solution.  Many have been offered and in typical settings they will rarely agree.

#### Latent Expressivity

You are never going to have it recommended that you take continuous outcomes or predictors and categorize them.  It is sometimes done as a computational convenience, but if you're interested in interpretability and inference, it's almost always the wrong choice.

Now ask, why would you do it with latent variables?  Unless there is very strong theory or an actual physical aspect involved (e.g. )



## Other

 - ICA
 - Recommender systems
 - Time-based (e.g. HMM)
 - Bayesian
 
 
## Issues

- how many latent factors/classes/
- two step models vs. simultaneous estimation for prediction



[^eigen]: They are the <span class="emph">eigenvalues</span> of the correlation matrix.  In addition, they are the diagonal of the crossproduct of the loading matrix.

[^rotated]: These results have been rotated, something practically no one using PCA actually does.  

[^badfactor]: Results like this are more the rule than the exception in my experience. Not enough initial development is typically done with scales, and when other people use them in other settings, it often ends with disappointment.  Just think, many psychological scales are developed on freshman psychology students.  How well do you think that will generalize?